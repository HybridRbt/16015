/*******************************************************************************
 *              Copyright(c) 2008, Mactronix Inc.
 *              All rights reserved
 *
 *              File:        func.lib
 *              Description: interface functions
 ******************************************************************************/
#use "util.lib"

/*** BeginHeader InitWhole */
int InitWhole();
/*** EndHeader */
int InitWhole()
{

	int re;
	unsigned char msgbuf[PCPORTOUTBUFSIZE];   /* buffer for RS232 message */

	//set servo parameters and enable servo
	if ((re = InitRoller()) != NO_ERROR)
		return re;

	if ((re = MoveBlockDown()) != NO_ERROR)
		return re;

	if ((re = RollerHome()) != NO_ERROR)
		return re;

	if (g_stage == IN_IO)
	{
		msgbuf[0] = 1;
		msgbuf[1] = MSG_INITIALIZED_OK;
		msgbuf[msgbuf[0] + 1] = '\0';

		if ((re = sendMsg(msgbuf)) != NO_ERROR)
			return re;
	}

	return NO_ERROR;
}

/*** BeginHeader SendPcReady */
xmem int SendPcReady();
/*** EndHeader */
/*==============================================================================
 *              SendPcReady
 *============================================================================*/
xmem int SendPcReady()
{
	/** send ready signal to host computer */
	int re;
	unsigned char msgbuf[PCPORTOUTBUFSIZE];   /* buffer for RS232 message */

	int slotnum;

	msgbuf[0] = 1;
	msgbuf[1] = MSG_SB_ASK_READY;
	msgbuf[msgbuf[0] + 1] = '\0';

   printf("sending ask for ready msg...\n");
	if ((re = sendMsg(msgbuf)) != NO_ERROR)
		return re;

   printf("msg sent.\n");
	return NO_ERROR;
}

/*** BeginHeader SendPcOpStarted */
xmem int SendPcOpStarted();
/*** EndHeader */
/*==============================================================================
 *              SendPcOpStarted
 *============================================================================*/
xmem int SendPcOpStarted()
{
	/** send ready signal to host computer */
	int re;
	unsigned char msgbuf[PCPORTOUTBUFSIZE];   /* buffer for RS232 message */

	int slotnum;

	if (!g_bConnected) // no connection, don't send
		return NO_ERROR;

	msgbuf[0] = 2;
	msgbuf[1] = MSG_START_OPERATION;

	if (IsFlatToUp())
		msgbuf[2] = FLAT_UP;
	else
		msgbuf[2] = FLAT_DOWN;

	msgbuf[msgbuf[0] + 1] = '\0';

	if ((re = sendMsg(msgbuf)) != NO_ERROR)
		return re;

	return NO_ERROR;
}

/*** BeginHeader GetWaferMap */
xmem int GetWaferMap(int flatCount);
/*** EndHeader */
/*==============================================================================
 *              GetWaferMap
 *============================================================================*/
xmem int GetWaferMap(int flatCount)
{
	/** generate wafer map based on the sensor map */
	int slotnum;
	int fullBoat;
   int waferCount;

	fullBoat = TRUE;
   waferCount = 0;

	for (slotnum = 1; slotnum <= 25; slotnum++)
	{
		if (IsWaferInSlot(slotnum))
		{
      	g_waferMap[slotnum - 1] = 1;
      	waferCount++;
      }
      else
		{
			g_waferMap[slotnum - 1] = 0;
			fullBoat = FALSE;
		}
	}

   if (flatCount == 0)  // all are 57
   	g_flatType = BG_WAFER;
   else if (flatCount < waferCount)  //47 57 mixed
   	g_flatType = MIXED;
   else if (flatCount == waferCount) // all are 47
   	g_flatType = SM_WAFER;

   return fullBoat;
}

/*** BeginHeader SendPcOpDone */
xmem void SendPcOpDone();
/*** EndHeader */
/*==============================================================================
 *              SendPcOpDone
 *============================================================================*/
xmem void SendPcOpDone()
{
	/** generate wafer map based on the sensor map */
	void *p2, *p3, *p4, *p5, *p6;
	int re;
	unsigned char msgbuf[PCPORTOUTBUFSIZE];   /* buffer for RS232 message */

	int slotnum;

	if (!g_bConnected) // no connection, don't send
		return NO_ERROR;

	msgbuf[0] = 6;
	msgbuf[1] = MSG_OPERATION_DONE;

	//byte 1 to pc
	p2 = &msgbuf[2];
	memset(p2, 0, 1);

	for (slotnum = 1; slotnum <= 8; slotnum++)
		g_waferMap[slotnum - 1] ? set(p2, (slotnum - 1)) : 0;

	//byte 2
	p3 = &msgbuf[3];
	memset(p3, 0, 1);

	for (slotnum = 9; slotnum <= 16; slotnum++)
		g_waferMap[slotnum - 1] ? set(p3, (slotnum - 9)) : 0;

	//byte 3
	p4 = &msgbuf[4];
	memset(p4, 0, 1);

	for (slotnum = 17; slotnum <= 24; slotnum++)
		g_waferMap[slotnum - 1] ? set(p4, (slotnum - 17)) : 0;

	//byte 4
	p5 = &msgbuf[5];
	memset(p5, 0, 1);
	g_waferMap[24] ? set(p5, 0) : 0;
	IsFlatToUp() ? set(p5, 1) : 0;
	IsBoatPresent() ? set(p5, 2) : 0;
	IsBlockUp() ? set(p5, 3) : 0;
	IsBlockDown() ? set(p5, 4) : 0;

	msgbuf[6] = g_flatType;

	msgbuf[msgbuf[0] + 1] = '\0';

	if ((re = sendMsg(msgbuf)) != NO_ERROR)
		return re;

	return NO_ERROR;
}

/*** BeginHeader GetSensorStatus */
xmem int GetSensorStatus();
/*** EndHeader */
/*==============================================================================
 *              GetSensorStatus
 *============================================================================*/
xmem int GetSensorStatus()
{
	/** send sensor's values to host computer */
	void *p2, *p3, *p4, *p5, *p6;
	int re;
	unsigned char msgbuf[PCPORTOUTBUFSIZE];   /* buffer for RS232 message */

	int slotnum;

	msgbuf[0] = 5;
	msgbuf[1] = MSG_SENSOR_STATUS;

	//byte 1 to pc
	p2 = &msgbuf[2];
	memset(p2, 0, 1);

	for (slotnum = 1; slotnum <= 8; slotnum++)
		IsWaferInSlot(slotnum) ? set(p2, (slotnum - 1)) : 0;

	//byte 2
	p3 = &msgbuf[3];
	memset(p3, 0, 1);

	for (slotnum = 9; slotnum <= 16; slotnum++)
		IsWaferInSlot(slotnum) ? set(p3, (slotnum - 9)) : 0;

	//byte 3
	p4 = &msgbuf[4];
	memset(p4, 0, 1);

	for (slotnum = 17; slotnum <= 24; slotnum++)
		IsWaferInSlot(slotnum) ? set(p4, (slotnum - 17)) : 0;

	//byte 4
	p5 = &msgbuf[5];
	memset(p5, 0, 1);
	IsWaferInSlot(25) ? set(p5, 0) : 0;
	IsFlatToUp() ? set(p5, 1) : 0;
	IsBoatPresent() ? 0 : set(p5, 2);
	IsBlockUp() ? set(p5, 3) : 0;
	IsBlockDown() ? set(p5, 4) : 0;

	msgbuf[msgbuf[0] + 1] = '\0';

	if ((re = sendMsg(msgbuf)) != NO_ERROR)
		return re;

	return NO_ERROR;
}

/*** BeginHeader init */
void init();
/*** EndHeader */
void init()
{
	/** initialize rabbit board, open serial port, and global variables */
	InitIOBoard();
	InitCommPort();
	NmcInit();			//get servo address
}

/*** BeginHeader InitIOBoard */
void InitIOBoard();
/*** EndHeader */
void InitIOBoard()
{
	/**
	 *\code
	 * configure analog/digital port
	 * BL 2600:
	 *   1) 36 digital IO
	 *      - 16 protected digital inputs: DIN16-DIN31, use digIn() to read
	 *      - 4 high-current digital outputs: HOUT0-HOUT3
	 *      - 16 software-configurable as input/output: DIO00-DIO15
	 *   2) 12 analog channels
	 *      - 8 11-bit A/D converter inputs
	 *      - 4 12-bit D/A converter outputs
	 * \endcode
	 */
	int i;
	/* Initialize the board, it must be called at the begining of program */
	brdInit();
	/* Digital High-current outputs: 0 = sinking operation   */
	//digHoutConfig(0x01);
	digHoutConfig(0x00);
	digHTriStateConfig(0x00);

	for (i = 0; i <= 3; i++)
		digHout(i, 1);

	/* 16 configurable I/O(DIO00-DIO15): configure 0 as digital output
	 * Set all digital outputs to be high-impedance state
	 */
	//0000 0000 0000 0001
	//0001
	digOutConfig(0x0001);

	digOut(0, 1);
}

/*** BeginHeader InitCommPort */
void InitCommPort(void);
/*** EndHeader */
void InitCommPort(void)
{
	if (!serCopen(BAUD19200))       //to NMC
		return;

	if (!serEopen(BAUD115200))      //to PC
		return;

	serMode(0);

	// Clear serial data buffers
	serCrdFlush();
	serCwrFlush();

	serErdFlush();
	serEwrFlush();

	serCdatabits(PARAM_8BIT);
	serCparity(PARAM_NOPARITY);

	serEdatabits(PARAM_8BIT);
	serEparity(PARAM_NOPARITY);
}

/*** BeginHeader myinp */
int myinp(int port);
/*** EndHeader */
int myinp(int port)
{
	/** read input port
	  @return 1 or 0    */
	int i, data;
	float temp;

	while (1)
	{
		data = 0;

		for (i = 0; i < 3; i++)
		{
			if (port > 0) //DIO01-DIO15 AND DIN16-DIN31 digital inputs
				data += digIn(port);
		}

		if (data > 2)
			return TRUE;
		else
			return FALSE;
	}
}

/*** BeginHeader boatCheck */
int boatCheck();
/*** EndHeader */
int boatCheck()
{
	if (IsBoatPresent())
		return NO_ERROR;

	ServoStopMotor(ROLLER_MOTOR, AMP_ENABLE | STOP_SMOOTH , 1);
	return ERR_CASSETTE_PRESENT;
}

/*** BeginHeader handleMsg */
xmem int handleMsg();
/*** EndHeader */

/*==============================================================================
 *           handleMsg
 *============================================================================*/
xmem int handleMsg()
{
	/**
	 * Message handler
	 */
	unsigned char bankdata;
	int id, re, in_io, keepSupportUp;
	unsigned char msgbuf[PCPORTOUTBUFSIZE];


	if (!(id = getMsg()))
		return NO_ERROR;

	re = NO_ERROR;

	switch (id)
	{
		case CMD_SENSOR_STATUS: // 1
			re = GetSensorStatus();
			break;


		case CMD_INITIAL_DATA:      // 2
			GetDataFromHost();
			break;

		case CMD_INITIALIZE:    // 3
			re = InitWhole();
			break;

		case CMD_IO:       // 4
			in_io = g_msgbuf[DATA_IDX];

			if (in_io == 1)
			{
				g_stage = IN_IO;
				//setOperationLight();
			}
			else
			{
				g_stage = READY;
				setIdleLight();
			}

			break;

		case CMD_NOTCH_FIND:          // 5
			keepSupportUp = g_msgbuf[DATA_IDX];

			if ((re = FindFlat()) != NO_ERROR)
				break;
			else
			{
				msgbuf[0] = 1;
				msgbuf[1] = MSG_IO_DONE;
				msgbuf[msgbuf[0] + 1] = '\0';
				sendMsg(msgbuf);

				PrepareForGetFlatType();  //for test
				/*
				if (keepSupportUp)
				{
					if ((re = MoveBlockUp()) == NO_ERROR)
				   {
					  msgbuf[0] = 1;
							msgbuf[1] = MSG_IO_DONE;
							msgbuf[msgbuf[0] + 1] = '\0';
							re = sendMsg(msgbuf);
				   }
				}
				else
				{
					msgbuf[0] = 1;
						msgbuf[1] = MSG_IO_DONE;
						msgbuf[msgbuf[0] + 1] = '\0';
						re = sendMsg(msgbuf);
				} */
			}

			break;

		case CMD_NF_SUPPORT_UP:        // 6
			if ((re = MoveBlockUp()) == NO_ERROR)
			{
				msgbuf[0] = 1;
				msgbuf[1] = MSG_IO_DONE;
				msgbuf[msgbuf[0] + 1] = '\0';
				re = sendMsg(msgbuf);
			}

			break;

		case CMD_NF_SUPPORT_DOWN:          // 7

			if ((re = MoveBlockDown()) == NO_ERROR)
			{
				msgbuf[0] = 1;
				msgbuf[1] = MSG_IO_DONE;
				msgbuf[msgbuf[0] + 1] = '\0';
				re = sendMsg(msgbuf);
			}

			break;

		case CMD_ABORT:
			//ResetPausedSignalToHost();
			//re = InitWhole();
			break;

		case CMD_ALARM: // 21
			recvAlarmMsg();
			break;

		case CMD_LIGHT: // 23
			SetLight();
			break;

		default:
			break;
	}

	if (re != NO_ERROR)
		sendErrMsg(re);

	return NO_ERROR;
}


/*** BeginHeader GetDataFromHost */
//xmem void GetDataFromHost();
/*** EndHeader */
/*==============================================================================
 *               setData
 *============================================================================*/
/*
xmem void GetDataFromHost()
{
	long beamShadowBottom_6, beamShadowTop_6, beamShadowBottom_8, beamShadowTop_8;

	g_posTrayIn_6 = (g_msgbuf[DATA_IDX] << 8);
	g_posTrayIn_6 |= g_msgbuf[DATA_IDX + 1];

	g_posTrayOut_6 = (g_msgbuf[DATA_IDX + 2] << 8);
	g_posTrayOut_6 |= g_msgbuf[DATA_IDX + 3];

	g_elevDownStepsForPick_6 = (g_msgbuf[DATA_IDX + 4] << 8);
	g_elevDownStepsForPick_6 |= g_msgbuf[DATA_IDX + 5];

	g_slot1Offset_6 = ((long)g_msgbuf[DATA_IDX + 6] << 8);
	g_slot1Offset_6 |= (long)g_msgbuf[DATA_IDX + 7];

	g_slot26Offset_6 = ((long)g_msgbuf[DATA_IDX + 8] << 24);
	g_slot26Offset_6 |= ((long)g_msgbuf[DATA_IDX + 9] << 16);
	g_slot26Offset_6 |= ((long)g_msgbuf[DATA_IDX + 10] << 8);
	g_slot26Offset_6 |= (long)g_msgbuf[DATA_IDX + 11];

	g_sensorOffset_6 = ((long)g_msgbuf[DATA_IDX + 12] << 8);
	g_sensorOffset_6 |= (long)g_msgbuf[DATA_IDX + 13];

	beamShadowBottom_6 = (g_msgbuf[DATA_IDX + 14] << 8);
	beamShadowBottom_6 |= g_msgbuf[DATA_IDX + 15];

	beamShadowTop_6 = (g_msgbuf[DATA_IDX + 16] << 8);
	beamShadowTop_6 |= g_msgbuf[DATA_IDX + 17];

	g_FFupOffset = g_msgbuf[DATA_IDX + 18];
	g_FFdownOffset = g_msgbuf[DATA_IDX + 19];
	g_FFleftOffset = g_msgbuf[DATA_IDX + 20];
	g_FFrightOffset = g_msgbuf[DATA_IDX + 21];
	g_NFupOffset6 = g_msgbuf[DATA_IDX + 22];
	g_NFdownOffset6 = g_msgbuf[DATA_IDX + 23];
	g_NFleftOffset6 = g_msgbuf[DATA_IDX + 24];
	g_NFrightOffset6 = g_msgbuf[DATA_IDX + 25];

	g_slot1Offset_8 = ((long)g_msgbuf[DATA_IDX + 26] << 8);
	g_slot1Offset_8 |= (long)g_msgbuf[DATA_IDX + 27];

	g_slot26Offset_8 = ((long)g_msgbuf[DATA_IDX + 28] << 24);
	g_slot26Offset_8 |= ((long)g_msgbuf[DATA_IDX + 29] << 16);
	g_slot26Offset_8 |= ((long)g_msgbuf[DATA_IDX + 30] << 8);
	g_slot26Offset_8 |= (long)g_msgbuf[DATA_IDX + 31];

	g_sensorOffset_8 = ((long)g_msgbuf[DATA_IDX + 32] << 8);
	g_sensorOffset_8 |= (long)g_msgbuf[DATA_IDX + 33];

	beamShadowBottom_8 = (g_msgbuf[DATA_IDX + 34] << 8);
	beamShadowBottom_8 |= g_msgbuf[DATA_IDX + 35];

	beamShadowTop_8 = (g_msgbuf[DATA_IDX + 36] << 8);
	beamShadowTop_8 |= g_msgbuf[DATA_IDX + 37];

	g_NFupOffset8 = g_msgbuf[DATA_IDX + 38];
	g_NFdownOffset8 = g_msgbuf[DATA_IDX + 39];
	g_NFleftOffset8 = g_msgbuf[DATA_IDX + 40];
	g_NFrightOffset8 = g_msgbuf[DATA_IDX + 41];

	g_posTrayIn_8 = (g_msgbuf[DATA_IDX + 42] << 8);
	g_posTrayIn_8 |= g_msgbuf[DATA_IDX + 43];

	g_posTrayOut_8 = (g_msgbuf[DATA_IDX + 44] << 8);
	g_posTrayOut_8 |= g_msgbuf[DATA_IDX + 45];

	g_pickWaferOffset6 = (g_msgbuf[DATA_IDX + 46] << 8);
	g_pickWaferOffset6 |= g_msgbuf[DATA_IDX + 47];

	g_pickWaferOffset8 = (g_msgbuf[DATA_IDX + 48] << 8);
	g_pickWaferOffset8 |= g_msgbuf[DATA_IDX + 49];

	g_trayPickWaferOffset_6 = (g_msgbuf[DATA_IDX + 50] << 8);
	g_trayPickWaferOffset_6 |= g_msgbuf[DATA_IDX + 51];

	g_trayPickWaferOffset_8 = (g_msgbuf[DATA_IDX + 52] << 8);
	g_trayPickWaferOffset_8 |= g_msgbuf[DATA_IDX + 53];

	//7/16/2015 3:19:12 PM @Jered add a global parameter for 8" wafer
	g_elevDownStepsForPick_8 = (g_msgbuf[DATA_IDX + 54] << 8);
	g_elevDownStepsForPick_8 |= g_msgbuf[DATA_IDX + 55];

	//@Jered add a global parameter for platform tilt
	// g_elevDwForPlatfromTilt = (g_msgbuf[DATA_IDX + 56] << 8);
	// g_elevDwForPlatfromTilt |= (g_msgbuf[DATA_IDX + 57]);

	// cross slot ratio per centage, 02-12-2016 dliu
	g_crossRatio_6 = g_msgbuf[DATA_IDX + 56];
	g_crossRatio_8 = g_msgbuf[DATA_IDX + 57];

	g_beamShadow_6 = (beamShadowBottom_6 + beamShadowTop_6) / 2;
	g_beamShadow_8 = (beamShadowBottom_8 + beamShadowTop_8) / 2;

	//DelayMilliseconds(1000);
	/*
		printf("g_posTrayIn= %d \n", g_posTrayIn_6);
		printf("g_posTrayOut= %d\n", g_posTrayOut_6);
		printf("g_posTrayIn_8= %d \n", g_posTrayIn_8);
		printf("g_posTrayOut_8= %d\n", g_posTrayOut_8);
		printf("g_elevDownStepsForPick_6= %d \n", g_elevDownStepsForPick_6);
		printf("g_elevDownStepsForPick_8= %d \n", g_elevDownStepsForPick_8);
		printf("slot1_6 offset = %ld\n", g_slot1Offset_6);
		printf("slot26_6 offset = %ld\n", g_slot26Offset_6);
		printf("6 Scan start at %ld\n", g_sensorOffset_6);
		printf("beamShadowBottom_6 = %ld\n", beamShadowBottom_6);
		printf("beamShadowTop_6 = %ld\n", beamShadowTop_6);
		printf("g_FFupOffset for 6= %d\n", g_FFupOffset);
		printf("g_FFdownOffset for 6= %d\n", g_FFdownOffset);
		printf("g_FFleftOffset for 6= %d\n", g_FFleftOffset);
		printf("g_FFrightOffset for 6= %d\n", g_FFrightOffset);
		printf("g_NFupOffset6= %d\n", g_NFupOffset6);
		printf("g_NFdownOffset6= %d\n", g_NFdownOffset6);
		printf("g_NFleftOffset6= %d\n", g_NFleftOffset6);
		printf("g_NFrightOffset6= %d\n", g_NFrightOffset6);
		printf("slot1_8 offset = %ld\n", g_slot1Offset_8);
		printf("slot26_8 offset = %ld\n", g_slot26Offset_8);
		printf("8 Scan start at %ld\n", g_sensorOffset_8);
		printf("beamShadowBottom_8 = %ld\n", beamShadowBottom_8);
		printf("beamShadowTop_8 = %ld\n", beamShadowTop_8);
		printf("g_NFupOffset8= %d\n", g_NFupOffset8);
		printf("g_NFdownOffset8= %d\n", g_NFdownOffset8);
		printf("g_NFleftOffset8= %d\n", g_NFleftOffset8);
		printf("g_NFrightOffset8= %d\n", g_NFrightOffset8);
		printf("g_pickWaferOffset6= %d\n", g_pickWaferOffset6);
		printf("g_pickWaferOffset8= %d\n", g_pickWaferOffset8);
		printf("g_trayPickWaferOffset_6= %d\n", g_trayPickWaferOffset_6);
		printf("g_trayPickWaferOffset_8= %d\n", g_trayPickWaferOffset_8);
		printf("g_elevDwForPlatfromTilt = %d \n", g_elevDwForPlatfromTilt);
		printf("g_crossRatio_6 = %d\n", g_crossRatio_6);
		printf("g_crossRatio_8 = %d\n", g_crossRatio_8);
	*/
//}

/*** BeginHeader recvAlarmMsg */
xmem void recvAlarmMsg();
/*** EndHeader */

/*==============================================================================
 *            recvAlarmMsg
 *============================================================================*/
xmem void recvAlarmMsg()
{
	if (g_msgbuf[DATA_IDX])    /* turn on alarm */
		AlarmOn();
	else    /* turn off alarm */
		AlarmOff();
}

/*** BeginHeader AlarmOn */
xmem void AlarmOn();
/*** EndHeader */
/*==============================================================================
 *             AlarmOn
 *============================================================================*/
xmem void AlarmOn()
{
	/** turn alamm on */
	digHout(ALARM_TRIG, 0);
}

/*** BeginHeader AlarmOff */
xmem void AlarmOff();
/*** EndHeader */
/*==============================================================================
 *             AlarmOff
 *============================================================================*/
xmem void AlarmOff()
{
	/** turn alamm off */
	digHout(ALARM_TRIG, 1);
}

/*** BeginHeader SetLight */
xmem void SetLight();
/*** EndHeader */
/*==============================================================================
 *               SetLight
 *============================================================================*/
xmem void SetLight()
{
	/** set light color */
	int color;

	color = g_msgbuf[DATA_IDX];

	SetLightLocal(color);
}

/*** BeginHeader SetRedLight */
xmem void SetRedLight();
/*** EndHeader */
/*==============================================================================
 *               SetRedLight
 *============================================================================*/
xmem void SetRedLight()
{
	digHout(LIGHT_RED_TRIG, 0);
}

/*** BeginHeader ResetRedLight */
xmem void ResetRedLight();
/*** EndHeader */
/*==============================================================================
 *               ResetRedLight
 *============================================================================*/
xmem void ResetRedLight()
{
	digHout(LIGHT_RED_TRIG, 1);
}

/*** BeginHeader SetGreenLight */
xmem void SetGreenLight();
/*** EndHeader */
/*==============================================================================
 *               SetGreenLight
 *============================================================================*/
xmem void SetGreenLight()
{
	digHout(LIGHT_GREEN_TRIG, 0);
}

/*** BeginHeader ResetGreenLight */
xmem void ResetGreenLight();
/*** EndHeader */
/*==============================================================================
 *               ResetGreenLight
 *============================================================================*/
xmem void ResetGreenLight()
{
	digHout(LIGHT_GREEN_TRIG, 1);
}

/*** BeginHeader setIdleLight */
xmem void setIdleLight();
/*** EndHeader */
/*==============================================================================
 *             setIdleLight
 *============================================================================*/
xmem void setIdleLight()
{
	int color;
	color = GREEN_LIGHT;

	SetLightLocal(color);
}

/*** BeginHeader setOperationLight */
xmem void setOperationLight();
/*** EndHeader */
/*==============================================================================
 *             setOperationLight
 *============================================================================*/
xmem void setOperationLight()
{
	int color;
	//color = GREEN_LIGHT;

	ResetGreenLight();
	ResetRedLight();
	AlarmOff();
	//SetLightLocal(color);
}

/*** BeginHeader setErrorLight */
xmem void setErrorLight();
/*** EndHeader */
/*==============================================================================
 *             setErrorLight
 *============================================================================*/
xmem void setErrorLight()
{
	int color;
	color = RED_LIGHT;

	SetLightLocal(color);
	AlarmOn();
}

/*** BeginHeader SetLightLocal */
xmem void SetLightLocal(int color);
/*** EndHeader */
/*==============================================================================
 *               SetLightLocal
 *============================================================================*/
xmem void SetLightLocal(int color)
{
	switch (color)
	{
		case RED_LIGHT:
			//        printf("light color: red\n");
			SetRedLight();
			ResetGreenLight();
			//ResetAmberLight();
			break;

		case GREEN_LIGHT:
			//printf("light color: green\n");
			SetGreenLight();
			ResetRedLight();
			//ResetAmberLight();
			break;

		case YELLOW_LIGHT:
			//printf("light color: yellow\n");
			//SetAmberLight();
			ResetGreenLight();
			ResetRedLight();
			break;

		default:
			break;
	}
}

/*** BeginHeader GetFlatType */
xmem int GetFlatType();
/*** EndHeader */
/*==============================================================================
 *               GetFlatType
 *============================================================================*/
xmem int GetFlatType()
{
	int slotnum;
	int flatType;
	int blockCounter;

	blockCounter = 0;

	for (slotnum = 1; slotnum <= 25; slotnum++)
	{
		if (IsWaferInSlot(slotnum))
			blockCounter++;  // if it's blocked, it's a sm
		else
			blockCounter--;  // if it's not blocked, it's a bg
	}

	if (blockCounter == 0) // all wafers are not blocked, all are bg
		flatType = BG_WAFER;
	else if (blockCounter == 25)  // all wafers are blocked, all are sm
		flatType = SM_WAFER;
	else
		// report mixed
		flatType = MIXED;
	
	return flatType;
}


/*---------------------------- end of func.lib -------------------------------*/